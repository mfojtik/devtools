
/*
 This file was autogenerated via
 ----------------------------------------
 ldetool generate --package glog glog.lde
 ----------------------------------------
 do not touch it with bare hands!
*/

package glog

import (
	"bytes"
)

var colonSpace = []byte(": ")

// Line ...
type Line struct {
	rest        []byte
	Hostname    []byte
	ServiceName []byte
	Level       []byte
	Time        []byte
	Filename    []byte
	Message     []byte
}

// Extract ...
func (p *Line) Extract(line []byte) (bool, error) {
	p.rest = line
	var pos int

	// Checks if rest[15:] starts with ' ' and pass it
	if len(p.rest) >= 15+1 && p.rest[15] == ' ' {
		p.rest = p.rest[15+1:]
	} else {
		return false, nil
	}

	// Take until ' ' as Hostname(string)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		p.Hostname = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	// Take until '[' as ServiceName(string)
	pos = bytes.IndexByte(p.rest, '[')
	if pos >= 0 {
		p.ServiceName = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	// Looking for ": " and then pass it
	pos = bytes.Index(p.rest, colonSpace)
	if pos >= 0 {
		p.rest = p.rest[pos+len(colonSpace):]
	} else {
		return false, nil
	}

	// Take until ' ' as Level(string)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		p.Level = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	// Take until ' ' as Time(string)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		p.Time = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if len(p.rest) >= 2 {
		p.rest = p.rest[2:]
	} else {
		return false, nil
	}

	// Looking for ' ' and then pass it
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	// Take until ']' as Filename(string)
	pos = bytes.IndexByte(p.rest, ']')
	if pos >= 0 {
		p.Filename = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	// Looking for ' ' and then pass it
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	// Take the rest as Message(string)
	p.Message = p.rest
	p.rest = p.rest[len(p.rest):]
	return true, nil
}
